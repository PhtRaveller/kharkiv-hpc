Домашнее задание #7
-------------------
.. role:: red

Задание 1.
==========
Циклы и условные переходы в bash.
+++++++++++++++++++++++++++++++++

Язык сценариев bash имеет несколько инструментов для циклов и условных переходов. В этом задании необходимо разобраться с циклами ``for`` и условной конструкцией ``if``.

Наиболее общий вид условной конструкции в ``bash`` такой::

    if list; then list; [ elif list; then list; ] ... [else list;] fi

``list`` здесь означает какой-либо набор команд или выражений. В случае, если в качестве условия выступает набор команд, берется значение возврата последней команды. Код возврата ``0`` считается в Unix успешным завершением. Так, следующий скрипт::

    if ls; pwd; then echo "OK"; else echo "Oops..."; fi

после вывода содержимого текущей директории и ее имени напечатает "OK". Эквивалентная запись::

    if ls; pwd
    then
        echo "OK"
    else
        echo "Oops..."
    fi

В ``bash`` есть два основных вида циклов: ``for`` и ``while``. Их синтаксис таков::

    for WORD in WORDS; do
        LIST
    done

    for WORD; do
        LIST
    done

    while LIST1; do
        LIST2
    done

Семантика цикла классического цикла ``for`` такова: в каждой итерации переменной ``WORD`` присваивается следующее слово из ``WORDS`` и выполняется последовательность команд ``LIST``. Код возврата из такой конструкции равен либо коду возврата послдней команды в ``LIST``, либо ``0``, если список ``WORDS`` пуст. Если ``WORDS`` не указан, используются позиционные аргументы. Например::

    > for x in 1 2 3; do echo $x; done
    1
    2
    3
    > echo $?
    0
    > for file in $(ls); do file -b $f | uniq; done # Выводит количество разных типов файлов в текущей директории.
        1 a /usr/bin/sh script, ASCII text executable # Есть один ASCII файл
        1 UTF-8 Unicode text # Есть один текстовый файл в unicode
    > echo $?
    0

Семантика цикла ``while`` аналогична семантике таких циклов в других языках, но есть несколько особенностей. Цикл ``while`` удобно использовать для чтения из ``STDIN``. Для этого надо использовать команду ``read``::

    # myscript.sh: выводит файлы в которых встречается слово junk. Можно напрямую это сделать, конечно.
    while read LINE
    do
        if grep junk "$LINE"; then rm "$LINE"; fi
    done

    > chmod u+x myscript
    > ls | ./myscript.sh
            if grep junk "$LINE"
        echo "$LINE is junk"
    myscript.sh is junk # Выводит в директории с ДЗ7 только сам скрипт - в нем-то слово огтл точно есть:)


Есть также цикл ``until`` и С-стиль цикла ``for``. Для составления тестов, которые могут быть использованы в условной конструкции или цикле, существует утилита ``test``.

Команда ``test`` может проводить огромное количество разных типов сравнений. Например, ::

    > MYVAR=4
    > test $MYVAR -eq 4
    > echo $? # Встроенная переменная $? дает код возврата последней команды (для группы команд - т.е. последней команды в группе)
    0
    > MYVAR=5
    > test $MYVAR -eq 4
    > echo $?
    1

сравнивает значение переменной ``MYVAR`` с ``4``. Код возврата равен ``0``, если ``MYVAR`` равна ``4``, или ``1``, в противном случае. У ``test`` есть синоним: ``[...]``::

    > [ $MYVAR -eq 4 ]
    > 1

Обратите внимание на пробелы вокруг скобок. Если эти пробелы не указать, то в порядке развертывания строки ``bash`` сделает вот что::

    [$MYVAR -eq 4 ] -> [5 -eq 4 ] -> command [5 not found.
    [ $MYVAR -eq 4] -> [ 5 -eq 4] -> missing `]'

Утилита ``test`` имеет специальные типы условий для работы с файлами и строками. Их довольно большое количество, поэтому приведу лишь некоторые::

    > [ -e conditionals.sh ] # Файл conditionals.sh существует? Ключик -e
    > [ -s conditionals.sh ] # Размер conditionals.sh ненулевой? Ключик -s
    > [ -e conditionals.sh -a -s conditionals.sh ] # Файл conditionals.sh существует и его размер ненулевой? Ключик -a - другой контекст - логическое И
    > [ README.rst -nt conditionals.sh ] # Файл README.rst моложе, чем conditionals.sh?
    > [ $MYVAR -gt 5 ] # Переменная myvar больше 5

Задание 2.
==========
Отображаем в приглашении терминала текущую ветку git-репозитория.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

``bash``, как и почти все в Linux, можно настроить под себя. В частности, можно изменить вид приглашения командной строки. В приглашении кроме имени пользователя, хоста и текущей директории можно отображать другую полезную информацию. Например, было бы удобно видеть имя текущей ветки, когда мы находимся внутри репозитория ``git``. Теперь, когда мы знаем условные конструкции, это легко сделать. Первым делом обратим внимание на три факта. Первый факт в том, что шаблон приглашения командной строки ``bash`` хранится во встроенной переменной ``PS1``::

    > echo $PS1
    \[$(ppwd)\]\u@\h:\w>

Здесь ``\u`` - имя пользователя, ``\h`` - имя хоста, ``\w`` - текущая директория. ``ppwd`` - функция, определенная в ``/etc/bash.bashrc`` и выполняющая black magic (на самом деле там довольно легко разобраться, но это не 3 минуты. Рекомендую заглянуть в этот файл на досуге). ``PS1`` разворачивается при каждой новом приглашении и может быть изменена в ``~/.bashrc`` (именно там нужно хранить пользовательские настройки ``bash``). Второй факт в том, что ``git`` умеет выводить имя текущей ветки по команде ``git branch``::

    > git branch
    * master

Третий факт в том, что команда ``tput`` позволяет много чего поменять в терминале. например, Цвет или начертание шрифта::

    > tput setf 1 # Установить цвет foreground в синий
    :red: `> tput bold` # Жирный шрифт
    > tput sgr0 # Сбросить все установленные аттрибуты